create database InventoryDB;
use InventoryDB;

CREATE TABLE inventory_forecasting (
    Date DATE,
    Store_ID VARCHAR(10),
    Product_ID VARCHAR(10),
    Category VARCHAR(20),
    Region VARCHAR(10),
    Inventory_Level INT,
    Units_Sold INT,
    Units_Ordered INT,
    Demand_Forecast FLOAT,
    Price FLOAT,
    Discount INT,
    Weather_Condition VARCHAR(20),
    Holiday_Promotion TINYINT,
    Competitor_Pricing FLOAT,
    Seasonality VARCHAR(20)
);

/*phase 1: to understand the data*/
SELECT * FROM inventorydb.inventory_forecasting;
select  *
from inventory_forecasting 
where Store_ID='S001' 
and Product_ID='P0016' 
and Category='Clothing' 
and Region='EAST'
order by date, Product_ID;

/*check data types and nulls*/

SELECT COLUMN_NAME, DATA_TYPE 
FROM INFORMATION_SCHEMA.COLUMNS 
WHERE TABLE_NAME = 'inventory_forecasting';

/*phase2: descriptive stats*/
-- Identifying No of Distinct Product IDs and StoreIDs.
/*there are 5 stores with 5 diff products. each product has 6 unique productid's*/
select count(*) as total, 
       count(distinct product_id) as uniqueProductIDs,
       count(distinct store_id) as uniquestore,
	   count(distinct category) as UniqueProd
from inventory_forecasting;


select sum(Inventory_Level) totalInventory, Category, sum(Price) as TotalPrice 
from inventory_forecasting
group by Category;

-- Yearly revenue generated by each category
select Year(date) as YearDate  ,Category, sum(Inventory_Level) totalInventory,  sum(Price*Units_Sold) as TotalPrice 
from inventory_forecasting
group by year (date), Category
order by year (date) desc ,Category Desc;

-- Yearly revenue generated by each category in each store.
select Year(date) as YearDate  ,Store_ID, Category, 
sum(Inventory_Level) totalInventory,  
round((sum(Price*Units_Sold)), 0) as TotalPrice 
from inventory_forecasting
group by year (date), Category, Store_ID
order by year (date) desc ,Category;

-- rank which category has the highest sale in each store in the year 2023
-- using subquery
select *,
rank() over( order by TotalSales desc) as RankByPrice
from
( 
  select Year(date) as YearDate  ,Store_ID, Category, Region,
  sum(Inventory_Level) totalInventory,  
  round((sum(Price*Units_Sold)), 0) as TotalSales
  from inventory_forecasting
  group by year (date), Store_ID, Category, Region
  -- order by year (date) desc 
)t
where store_ID = 'S005' and YearDate = 2023;
-- Store S001 has the higest sale of clothing in the east region. while groceries has the lowest sale in the west region.
-- store s002 has the higest sale of clothing in the east region. while groceries has the lowest sale in the north region.
-- store s003 has the higest sale of clothing in the east region. while groceries has the lowest sale in the south region.
-- store s004 has the higest sale of clothing in the north region. while groceries has the lowest sale in the west region.
-- store s005 has the higest sale of clothing in the east region. while groceries has the lowest sale in the west region.

-- Now to Analyze on the Inventory
-- 1. Comparing no of units left in the inventory v/s no of units ordered.
SELECT Store_ID,
       Product_ID,
       Category,
       Region,
       Inventory_Level,
       Units_Sold,
       (Inventory_Level - Units_Sold) as Units_Left,
       Units_Ordered,
       Demand_Forecast
       FROM inventorydb.inventory_forecasting;
       
-- adding total units left and ordered to see how much do they match the forecast
select *, (Units_Left + Units_Ordered) as UnitsMatch
from
(
  SELECT Year(date) as YearDate, Store_ID,
       Product_ID,
       Category,
       Region,
       Inventory_Level,
       Units_Sold,
       (Inventory_Level - Units_Sold) as Units_Left,
       Units_Ordered,
       Demand_Forecast
       FROM inventorydb.inventory_forecasting
)t
where Yeardate = 2023 and Category = 'Clothing'
order by Units_Left;


-- total category has negative units left ; here we have to use CTEs
select *
from
(
  SELECT Year(date) as YearDate, Store_ID,
       Product_ID,
       Category,
       Region,
       Inventory_Level,
       Units_Sold,
       (Inventory_Level - Units_Sold) as Units_Left,
       Units_Ordered,
       Demand_Forecast
       FROM inventorydb.inventory_forecasting
)t
where Yeardate = 2023;
-- order by Units_Left;


-- we need to build a schema
select distinct product_id, category from inventory_forecasting;

-- tables: store(pk-storeid), product(pk-productid), competitive(pk-storeid/productid)

-- tables
create table Store(Store_ID varchar(10) , Region varchar(8),  primary key(Store_ID, Region));
create table Product(Product_ID varchar(10) primary key, Category varchar(20));
create table Inventory(
    Date DATE,
    Store_ID VARCHAR(10),
    Product_ID VARCHAR(10),
    Inventory_Level INT,
    Units_Sold INT,
    Units_Ordered INT,
    Price float,
    Demand_Forecast FLOAT,
    Discount INT,
    Weather_Condition VARCHAR(20),
    Holiday_Promotion TINYINT,
    Competitor_Pricing FLOAT,
    Seasonality VARCHAR(20),
    PRIMARY KEY (Date, Store_ID, Product_ID),
    FOREIGN KEY (Store_ID) REFERENCES Store(Store_ID),
    FOREIGN KEY (Product_ID) REFERENCES Product(Product_ID)
);

-- adding the data to store table
INSERT INTO Store (Store_ID, Region)
SELECT DISTINCT Store_ID, Region
FROM inventory_forecasting;

-- adding data to product table
INSERT INTO Product(Product_ID, Category)
SELECT DISTINCT product_id, Category
FROM inventory_forecasting;

select * from Product;

-- adding the other time-dependent data in Inventory table
INSERT INTO Inventory (
    Date,
    Store_ID,
    Product_ID,
    Inventory_Level,
    Units_Sold,
    Units_Ordered,
    Price,
    Demand_Forecast,
    Discount,
    Weather_Condition,
    Holiday_Promotion,
    Competitor_Pricing,
    Seasonality
)
SELECT 
    CAST(Date AS DATE),
    Store_ID,
    Product_ID,
    Inventory_Level,
    Units_Sold,
    Units_Ordered,
    Price,
    Demand_Forecast,
    Discount,
    Weather_Condition,
    Holiday_Promotion,
    Competitor_Pricing,
    Seasonality
FROM inventory_forecasting;

/* To perform Stock Level Calculations:
- How much stock is left after the units are sold?
- rank products based on their demand.
- total units in the inventory after ordering the units.
- percentage of units that do not satisfy the demand forecast.
- Percentage demand of each product*/

-- How much stock is left after the units are sold?
SELECT Date,
       Store_ID,
       Product_ID,
       Inventory_Level,
       Units_Sold,
       (Inventory_Level - Units_Sold) as Units_Left
       FROM inventorydb.inventory
       where store_id = 'S001'
       order by Date,product_id;

-- units left less than 0 for the year 2023

SELECT Date,
       Store_ID,
       Product_ID,
       Inventory_Level,
       Units_Sold,
       (Inventory_Level - Units_Sold) as Units_Left
       FROM inventorydb.inventory
       where store_id = 'S001' and (Inventory_Level - Units_Sold) <= 0 and Year(Date) = 2023
       order by Date,product_id;
       
-- Monthly
SELECT 
    DATE_FORMAT(Date, '%Y-%m') AS YearMonth,
    Store_ID,
    Product_ID,
    sum(Units_Ordered) as totalUorder,
    SUM(Inventory_Level - Units_Sold) AS Units_Left
FROM inventorydb.inventory
WHERE 
    Store_ID = 'S001'
    AND (Inventory_Level - Units_Sold) <= 0
    AND DATE_FORMAT(Date, '%Y') = '2023'
GROUP BY 
    Store_ID, 
    Product_ID, 
    DATE_FORMAT(Date, '%Y-%m')
ORDER BY 
    Product_ID, YearMonth;
    
-- annually units understock for S001 
SELECT date_format(Date, '%Y') as Yearly,
       i.Store_ID,
       i.Product_ID,
       p.Category,
       sum((Inventory_Level - Units_Sold)) as Units_Left
       FROM inventorydb.inventory as i
       left join Product p
       on p.Product_ID = i.Product_ID
       where store_id = 'S001' and (Inventory_Level - Units_Sold) <= 0 and date_format(Date, '%Y') = '2023'
       group by store_id, product_id, date_format(Date, '%Y');

 -- units ordered monthly
 SELECT 
    DATE_FORMAT(Date, '%Y-%m') AS YearMonth,
    Store_ID,
    Product_ID,
    sum(Units_Ordered) as totalUorder,
    SUM(Inventory_Level - Units_Sold) AS Units_Left
FROM inventorydb.inventory
WHERE 
    Store_ID = 'S001'
    AND (Inventory_Level - Units_Sold) <= 0
    AND DATE_FORMAT(Date, '%Y') = '2023'
GROUP BY 
    Store_ID, 
    Product_ID, 
    DATE_FORMAT(Date, '%Y-%m')
ORDER BY 
    Product_ID, YearMonth;
    
-- avg units_left for each product
select *,
avg(Units_Left) over(partition by Product_ID order by YearMonth ) as avgunitsunderstock 
from
(
SELECT 
    DATE_FORMAT(Date, '%Y-%m') AS YearMonth,
    Store_ID,
    Product_ID,
    sum(Units_Ordered) as totalUorder,
    SUM(Inventory_Level - Units_Sold) AS Units_Left
FROM inventorydb.inventory
WHERE 
    Store_ID = 'S001'
    AND (Inventory_Level - Units_Sold) <= 0
    AND DATE_FORMAT(Date, '%Y') = '2023'
GROUP BY 
    Store_ID, 
    Product_ID, 
    DATE_FORMAT(Date, '%Y-%m')
)t; -- we get avg reorder point for each product in a certain month.

-- we get avg reorder point for each product in a year.

select *,
avg(Units_Left) over(partition by Product_ID order by Yearly) as avgunitsunderstock 
from
(
SELECT 
    DATE_FORMAT(Date, '%Y') AS Yearly,
    Store_ID,
    Product_ID,
    sum(Units_Ordered) as totalUorder,
    sum(Inventory_Level - Units_Sold) AS Units_Left
FROM inventorydb.inventory
WHERE 
	(Inventory_Level - Units_Sold) <= 0
    AND Store_ID = 'S001'
GROUP BY 
    Store_ID, 
    Product_ID, 
    DATE_FORMAT(Date, '%Y'))t;
/*
when i add this below statement in the above code, why is the totalUnitsOrdered changing? 
-> because (Inventory_Level - Units_Sold) <= 0 this code only shows the items with understock*/

-- for verification
/*select DATE_FORMAT(Date, '%Y') yy, Store_ID, Product_ID, sum(Units_Ordered) totalUorder, round(avg(Inventory_Level - Units_Sold),0) as AvgUnits_left from inventorydb.inventory
where (Inventory_Level - Units_Sold) <= 0
group by DATE_FORMAT(Date, '%Y'), Store_ID, Product_ID
order by DATE_FORMAT(Date, '%Y'), Product_ID
;*/

-- rank products based on their demand.
-- ek hi product ka 1 din mein 5 different forecasts hai, 5 products hai toh ek din mein 25 forecasts

-- per day forcast of a specific product in 2 years
select Date, product_id, avg(Demand_Forecast) as avgdemand from inventorydb.inventory
where Product_id = 'P0016' 
group by Date, product_id
order by Date, product_id;

-- per month forecast
select date_format(Date, '%Y-%M'), product_id, avg(Demand_Forecast) as avgdemand from inventorydb.inventory
where Product_id = 'P0016' 
group by date_format(Date, '%Y-%M'), product_id
order by product_id
;

-- rank products based on their demand.
select *, 
rank() over(order by avgdemand desc) as RankDemands,
case when avgdemand >= 150 then 'Highly Demanded'
	 when avgdemand < 100 then 'Less in Demand'
end as DemandCategory
from
(
select date_format(Date, '%Y-%M') as Monthly, product_id, round(avg(Demand_Forecast), 0) as avgdemand from inventorydb.inventory 
group by date_format(Date, '%Y-%M'), product_id
order by product_id)t
where Monthly = '2023-November';

-- To Identify top 5 most demanded product and top 5 least demanded prod in November 2023; 
select *, 
case when avgdemand >= 150 then 'Highly Demanded'
     when avgdemand >= 100 and avgdemand < 150 then 'Stable Demands'
	 when avgdemand < 100 then 'Less in Demand'
end as DemandCategory,
dense_rank() over(order by avgdemand desc) as RankDemands
from
(
select date_format(Date, '%Y-%M') as Monthly, product_id, round(avg(Demand_Forecast), 0) as avgdemand from inventorydb.inventory 
group by date_format(Date, '%Y-%M'), product_id
order by product_id)t
where Monthly = '2023-November';

-- total units in each store's inventory after ordering the units.

select *, (orderedthisMonth + Unit_Left) as NewInv
from
(select date_format(Date, '%Y-%m') as YearMonth, Store_ID, Product_ID, 
       sum(Inventory_Level) as curr_inv,
       (sum(Inventory_Level)-sum(Units_Sold)) as Unit_left ,
       sum(Units_Ordered) as orderedthisMonth,
       round(sum(Demand_Forecast),0) as demandspermonth
	   from inventorydb.inventory
       where date_format(Date, '%Y') = '2023'
	   group by date_format(Date, '%Y-%m'),Store_ID, Product_ID)t;
 
-- percentage of units that do not satisfy the demand forecast.
select *, 
row_number() over(partition by Product_ID,YearMonth order by Percent_Unsatisfied_Demand desc) as MostUnsatisfieddemands
from
(
SELECT 
  DATE_FORMAT(Date, '%Y') AS YearMonth,
  Store_ID,
  Product_ID,
  ROUND(
    100.0 * SUM(CASE WHEN Units_Sold < Demand_Forecast THEN 1 ELSE 0 END) 
    / COUNT(*), 1 
  ) AS Percent_Unsatisfied_Demand
FROM inventorydb.inventory
GROUP BY YearMonth, Store_ID,Product_ID
ORDER BY YearMonth, Store_ID)t;

-- each product has 5 different prices in 5 diff stores.
/*Low Inventory Detection:
- Identify products which are going under stock( negative units)
- Difference in time in fulfilling a certain understock
- how much time does it take for a certain product to go understock?
- which store has the lowest inventory and in which region?
- which product is selling fast, how much time does it take for the inventory to clear.*/

/*Time-Based Analysis/trend analysis
- seasonal performance of each store yearly
- weekly performance of each product in a specific store during holiday promotion.(to check if promotion affects the stock)
- regional performance of each store bi-annually.*/

-- seasonal performance of each store yearly
select * from inventorydb.inventory;

-- avg demand of products based on weather
SELECT 
    date_format(i.Date, '%Y') as yy,
    s.Region,
    i.Weather_Condition,
    ROUND(AVG(i.Demand_Forecast), 2) AS Avg_Demand_Forecast,
    COUNT(*) AS Record_Count
FROM inventorydb.inventory i
left join Store s
on s.Store_ID = i.Store_ID
GROUP BY date_format(i.Date, '%Y'),i.Weather_Condition, s.Region
ORDER BY Avg_Demand_Forecast DESC;

-- Sunny weather had more demand of products in 2023 follwed by Snowy
-- cloudy had more demand in 2022 followed by sunny.                       All of these across all region.
 
 -- which products are more demanded in Sunny in 2023?
 SELECT 
    date_format(i.Date, '%Y') as yy,
    p.Category,
    i.Weather_Condition,
    ROUND(AVG(i.Demand_Forecast), 2) AS Avg_Demand_Forecast,
    COUNT(*) AS Record_Count
FROM inventorydb.inventory i
left join Product p
on p.Product_ID = i.Product_ID
where date_format(i.Date, '%Y') = '2023'
GROUP BY date_format(i.Date, '%Y'),i.Weather_Condition, p.Category
ORDER BY Avg_Demand_Forecast DESC;

-- Clothing and Groceries are most demanded products in every season in year 2023 on avg.

-- seasonal performance of each product yearly
select * 
from
(select date_format(i.Date, '%Y') as yy, Seasonality, p.Category,
       round(avg(((Inventory_Level-Units_Sold)+Units_Ordered)*Price),1) as Sales, 
       count(*),
       row_number() over(partition by Seasonality order by round(avg(((Inventory_Level-Units_Sold)+Units_Ordered)*Price),1) desc) as ranks
from inventorydb.inventory i
left join Product p
on p.Product_ID = i.Product_ID
group by date_format(i.Date, '%Y'),Seasonality,p.Category)t
where ranks = 1;

-- season wise sales 
-- clothing generates the most sales in all seasons except spring.
-- followed by Electronics in all seasons except spring.

-- Which Store Produces the Highest avg Sales? 
select * 
from
(select date_format(i.Date, '%Y') as yy, Seasonality, s.Store_ID,
       round(avg(((Inventory_Level-Units_Sold)+Units_Ordered)*Price),1) as Sales, 
       count(*),
       row_number() over(partition by Seasonality order by round(avg(((Inventory_Level-Units_Sold)+Units_Ordered)*Price),1) desc) as ranks
from inventorydb.inventory i
left join Store s
on s.Store_ID = i.Store_ID
group by date_format(i.Date, '%Y'),Seasonality,s.Store_ID)t
where ranks = 1;

-- Which Regional Store produces the max sales
-- with seasons
select * 
from
(select date_format(i.Date, '%Y') as yy, Seasonality, s.Store_ID, s.Region,
       round(avg(((Inventory_Level-Units_Sold)+Units_Ordered)*Price),1) as Sales, 
       count(*),
       row_number() over(partition by Seasonality order by round(avg(((Inventory_Level-Units_Sold)+Units_Ordered)*Price),2) desc,date_format(i.Date, '%Y')) as ranks
from inventorydb.inventory i
left join Store s
on s.Store_ID = i.Store_ID
group by date_format(i.Date, '%Y'),Seasonality,s.Store_ID,s.Region)t
where ranks = 1;

-- without seasons
select * 
from
(select date_format(i.Date, '%Y') as yy, s.Store_ID, s.Region,
       round(avg(((Inventory_Level-Units_Sold)+Units_Ordered)*Price),1) as Sales, 
       count(*),
       row_number() over(partition by Region order by round(avg(((Inventory_Level-Units_Sold)+Units_Ordered)*Price),2) desc, date_format(i.Date, '%Y')) as ranks
from inventorydb.inventory i
left join Store s
on s.Store_ID = i.Store_ID
group by date_format(i.Date, '%Y'),s.Store_ID,s.Region)t
where ranks=1;

-- Store S005 produces the highest sales on avg.

-- regional performance of each store bi-annually.
SELECT 
    YEAR(i.Date) AS yy,
    s.Store_ID,
    s.Region,
    CASE 
        WHEN MONTH(i.Date) BETWEEN 1 AND 6 THEN 'H1'
        ELSE 'H2'
    END AS Half,
    ROUND(AVG(((Inventory_Level - Units_Sold) + Units_Ordered) * Price), 1) AS Sales,
    COUNT(*) AS Records
FROM inventorydb.inventory i
LEFT JOIN Store s ON s.Store_ID = i.Store_ID
GROUP BY 
    YEAR(i.Date),
    Half,
    s.Store_ID,
    s.Region
ORDER BY 
    YEAR(i.Date), Half, s.Region, s.Store_ID;

-- weekly performance of each product in a specific store during holiday promotion.

-- Affect of Promotion on Sales
select Year(Date) as yy, monthname(Date) as MonthN, 
       round(avg(((Inventory_Level-Units_Sold)+Units_Ordered)*Price),1) as Sales, 
	   Holiday_Promotion 
from inventorydb.inventory
group by Year(Date), monthname(Date),Holiday_Promotion 
;

/*TIME SERIES: MOVING AVERAGE, --Analyze the Month-over-Month(MoM) Performance by 
--finding the percentage change in sales between the
--current and previous month(TIME SERIES ANALYSIS) */

SELECT 
    YearMonth, Stores,
    ROUND(current_month_sales, 1) AS current_month_sales,
    ROUND(prev_month_sales, 1) AS prev_month_sales,
    ROUND(current_month_sales - prev_month_sales, 1) AS MOM_change,
    CASE 
        WHEN prev_month_sales = 0 THEN NULL
        ELSE ROUND(((current_month_sales - prev_month_sales) / prev_month_sales) * 100, 1)
    END AS MOM_percent_change
FROM (
    SELECT 
        DATE_FORMAT(Date, '%Y-%m') AS YearMonth, s.Store_ID as stores,
        SUM(ROUND(((Inventory_Level - Units_Sold) + Units_Ordered) * Price, 1)) AS current_month_sales,
        LAG(SUM(ROUND(((Inventory_Level - Units_Sold) + Units_Ordered) * Price, 1))) 
            OVER (ORDER BY DATE_FORMAT(Date, '%Y-%m')) AS prev_month_sales
    FROM inventorydb.inventory i
    left join Store s
    on s.Store_ID = i.Store_ID
    GROUP BY s.Store_ID, DATE_FORMAT(Date, '%Y-%m')
) AS t
where stores = 'S001';

select version();

/*RUNNING TOTAL: AGGREGATE ALL VALUES FOM THE BEGINNING
UP TO THE CURRENT POINT WITHOUT DROPPING OFF OLDER
DATA.
*/

-- Calculate MA of sales for each product over time
select *,
avg(Sales) over (partition by Product_ID) avgbyprod,
avg(Sales) over (partition by Product_ID order by yy) movingavg
from
(
select date_format(i.Date, '%Y-%m') as yy, i.Product_ID, 
ROUND((((Inventory_Level - Units_Sold) + Units_Ordered) * Price), 1) AS Sales
from inventorydb.inventory i
left join Product p
on p.Product_ID = i.Product_ID
group by date_format(i.Date, '%Y-%m'),i.Product_ID,ROUND((((Inventory_Level - Units_Sold) + Units_Ordered) * Price), 1)
)t;

-- reorder point estimation
-- Average Daily Usage (per Store + Product)
SELECT 
    Store_ID,
    Product_ID,
    ROUND(AVG(Units_Sold), 0) AS Avg_Daily_Usage
FROM inventorydb.inventory
GROUP BY Store_ID, Product_ID;

-- calculating avg lead time by identifying the avg difference between each product inv order.
select date_format(Date, '%Y-%m') as yy, Store_ID, Product_ID, Inventory_Level, 
LAG(Inventory_Level) OVER (
        PARTITION BY Store_ID, Product_ID 
        ORDER BY date_format(Date, '%Y-%m')) AS Prev_Inventory,
ROUND((Inventory_Level + 
           LAG(Inventory_Level) OVER (PARTITION BY Store_ID, Product_ID ORDER BY date_format(Date, '%Y-%m'))) / 2, 1) AS Avg_Daily_Inventory
from inventorydb.inventory
where Store_ID = 'S001'and Product_ID = 'P0016';

select * , 
case when Avg_Daily_Inventory <= 100 then 'Low_Inventory'
     else 'Normal'
end as Inventory_Status
from
(select date_format(Date, '%Y-%m') as yy, Store_ID, Product_ID, sum(Inventory_Level),
LAG(Inventory_Level) OVER (
        PARTITION BY Store_ID, Product_ID 
        ORDER BY date_format(Date, '%Y-%m')) AS Prev_Inventory,
ROUND((Inventory_Level + 
           LAG(Inventory_Level) OVER (PARTITION BY Store_ID, Product_ID ORDER BY date_format(Date, '%Y-%m'))) / 2, 1) AS Avg_Daily_Inventory
from inventorydb.inventory)t
group by yy, Store_ID, Product_ID, 
case when Avg_Daily_Inventory <= 100 then 'Low_Inventory'
     else 'Normal'
end;


/* assuming lead time is 2 days since the inventory is filled everyday for each product. I will calculate the safety stock.
Safety Stock = Z × σ × √L
Where:
Z = Service level constant (e.g., 1.65 for 95%, 2.33 for 99%)
σ = Standard deviation of daily demand (Units Sold)
L = Lead time in days (2)
√L = Because variation scales with time (random walk)*/

SELECT 
    Store_ID,
    Product_ID,
    ROUND(STDDEV(Units_Sold), 2) AS Std_Dev_Daily_Sales,
    2 AS Lead_Time_Days,
    1.65 AS Z_Score_95pct,
    ROUND(1.65 * STDDEV(Units_Sold) * SQRT(2), 2) AS Safety_Stock
FROM inventorydb.inventory
GROUP BY Store_ID, Product_ID;

-- now estimating reorder point;
SELECT 
    Store_ID,
    Product_ID,
    sum(Inventory_Level),
    ROUND((Inventory_Level + 
           LAG(Inventory_Level) OVER (PARTITION BY Store_ID, Product_ID )) / 2, 1) AS Avg_Daily_Inventory,
    2 AS Lead_Time_Days,
    ROUND(1.5 * STDDEV(Units_Sold), 2) AS Safety_Stock,
    ROUND((2 * AVG(Units_Sold)) + (1.5 * STDDEV(Units_Sold)), 2) AS Reorder_Point
FROM inventorydb.inventory
GROUP BY Store_ID, Product_ID;

-- Low Inventory
-- which store has the lowest inventory and in which region?
WITH Inventory_With_Lag AS (
    SELECT 
        Date,
        DATE_FORMAT(Date, '%Y-%m') AS Month,
        Store_ID,
        Product_ID,
        Inventory_Level,
        LAG(Inventory_Level) OVER (
            PARTITION BY Store_ID, Product_ID 
            ORDER BY Date
        ) AS Prev_Inventory
    FROM inventorydb.inventory
)

SELECT 
    Month,
    Store_ID,
    Product_ID,
    ROUND(AVG((Inventory_Level + Prev_Inventory) / 2), 1) AS Avg_monthly_Inventory,
    CASE 
        WHEN ROUND(AVG((Inventory_Level + Prev_Inventory) / 2), 1) <= 150 THEN 'Low_Inventory'
        ELSE 'Normal'
    END AS Inventory_Status
FROM Inventory_With_Lag
WHERE Prev_Inventory IS NOT NULL  -- Optional: exclude first day with NULL lag
GROUP BY Month, Store_ID, Product_ID
ORDER BY Month;

