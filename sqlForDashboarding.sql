-- sql codes for dashboard.
use InventoryDB;

-- 1. Identify Fast-Selling vs. Slow-Moving Products
-- Query: Rank products based on demand in November 2023 (Top 5 most/least demanded products)

SELECT *, 
    CASE 
        WHEN avgdemand >= 150 THEN 'Highly Demanded'
        WHEN avgdemand >= 100 AND avgdemand < 150 THEN 'Stable Demands'
        WHEN avgdemand < 100 THEN 'Less in Demand'
    END AS DemandCategory,
    DENSE_RANK() OVER(ORDER BY avgdemand DESC) AS RankDemands
FROM (
    SELECT DATE_FORMAT(Date, '%Y-%M') AS Monthly, product_id, ROUND(AVG(Demand_Forecast), 0) AS avgdemand 
    FROM inventorydb.inventory 
    GROUP BY DATE_FORMAT(Date, '%Y-%M'), product_id
    ORDER BY product_id
) t
WHERE Monthly = '2023-November';

-- creating store procedures
delimiter //
create procedure GetRankDemand (in Monthlys nvarchar(50)) 
begin
SELECT *, 
    CASE 
        WHEN avgdemand >= 150 THEN 'Highly Demanded'
        WHEN avgdemand >= 100 AND avgdemand < 150 THEN 'Stable Demands'
        WHEN avgdemand < 100 THEN 'Less in Demand'
    END AS DemandCategory,
    DENSE_RANK() OVER(ORDER BY avgdemand DESC) AS RankDemands
FROM (
    SELECT DATE_FORMAT(Date, '%Y-%M') AS Monthly, product_id, ROUND(AVG(Demand_Forecast), 0) AS avgdemand 
    FROM inventorydb.inventory 
    GROUP BY DATE_FORMAT(Date, '%Y-%M'), product_id
    ORDER BY product_id
) t
WHERE Monthly = Monthlys;
end //
delimiter ;

-- Query: Yearly revenue generated by each category in each store
SELECT YEAR(date) AS YearDate, Store_ID, Category, 
       SUM(Inventory_Level) AS totalInventory,  
       ROUND((SUM(Price * Units_Sold)), 0) AS TotalPrice 
FROM inventory_forecasting
GROUP BY YEAR(date), Category, Store_ID
ORDER BY YEAR(date) DESC, Category;

-- stored procedure
DELIMITER //
CREATE PROCEDURE GetYearlyRevenue(IN yearInput INT)
BEGIN
    SELECT YEAR(date) AS YearDate, Store_ID, Category, 
           SUM(Inventory_Level) AS totalInventory,  
           ROUND((SUM(Price * Units_Sold)), 0) AS TotalPrice 
    FROM inventorydb.inventory
    WHERE YEAR(date) = yearInput
    GROUP BY YEAR(date), Category, Store_ID
    ORDER BY YEAR(date) DESC, Category;
END //
DELIMITER ; 

-- 2. Recommend Stock Adjustments to Reduce Holding Costs
-- Query: Units left after sales for Store S001 (including negative units in 2023)

SELECT Date, Store_ID, Product_ID, Inventory_Level, Units_Sold, 
       (Inventory_Level - Units_Sold) AS Units_Left
FROM inventorydb.inventory
WHERE Store_ID = 'S001' AND (Inventory_Level - Units_Sold) <= 0 AND YEAR(Date) = 2023
ORDER BY Date, Product_ID;

-- stored procedure
DELIMITER //
CREATE PROCEDURE GetUnderstockedProducts(IN storeID VARCHAR(10), IN yearInput INT)
BEGIN
    SELECT Date, Store_ID, Product_ID, Inventory_Level, Units_Sold, 
           (Inventory_Level - Units_Sold) AS Units_Left
    FROM inventorydb.inventory
    WHERE Store_ID = storeID AND (Inventory_Level - Units_Sold) <= 0 AND YEAR(Date) = yearInput
    ORDER BY Date, Product_ID;
END //
DELIMITER ;

-- Query: Monthly units understock for Store S001 in 2023

SELECT DATE_FORMAT(Date, '%Y-%m') AS YearMonth, Store_ID, Product_ID, 
       SUM(Units_Ordered) AS totalUorder, SUM(Inventory_Level - Units_Sold) AS Units_Left
FROM inventorydb.inventory
WHERE Store_ID = 'S001' AND (Inventory_Level - Units_Sold) <= 0 AND DATE_FORMAT(Date, '%Y') = '2023'
GROUP BY Store_ID, Product_ID, DATE_FORMAT(Date, '%Y-%m')
ORDER BY Product_ID, YearMonth;

-- stored procedures
DELIMITER //
CREATE PROCEDURE GetMonthlyUnderstock(IN storeID VARCHAR(10), IN yearInput VARCHAR(4))
BEGIN
    SELECT DATE_FORMAT(Date, '%Y-%m') AS YearMonth, Store_ID, Product_ID, 
           SUM(Units_Ordered) AS totalUorder, SUM(Inventory_Level - Units_Sold) AS Units_Left
    FROM inventorydb.inventory
    WHERE Store_ID = storeID AND (Inventory_Level - Units_Sold) <= 0 AND DATE_FORMAT(Date, '%Y') = yearInput
    GROUP BY Store_ID, Product_ID, DATE_FORMAT(Date, '%Y-%m')
    ORDER BY Product_ID, YearMonth;
END //
DELIMITER ;

-- Query: Reorder point estimation

SELECT 
    DATE_FORMAT(Date, '%Y-%m') AS Month,
    Store_ID,
    Product_ID,
    ROUND(AVG(Inventory_Level), 1) AS Avg_Inventory_Level,
     IFNULL(ROUND(
        (AVG(Inventory_Level) + 
         LAG(AVG(Inventory_Level)) OVER (
             PARTITION BY Store_ID, Product_ID 
             ORDER BY DATE_FORMAT(Date, '%Y-%m')
         )
        ) / 2, 1
    ),0) AS Avg_Monthly_Inventory,
    2 AS Lead_Time_Days,
    ROUND(1.5 * STDDEV(Units_Sold), 2) AS Safety_Stock,
    ROUND((2 * AVG(Units_Sold)) + (1.5 * STDDEV(Units_Sold)), 2) AS Reorder_Point
FROM inventorydb.inventory
WHERE DATE_FORMAT(Date, '%Y') = '2023'
GROUP BY 
    DATE_FORMAT(Date, '%Y-%m'), 
    Store_ID, 
    Product_ID
ORDER BY Month, Store_ID, Product_ID;

-- stored procedure
delimiter //
create procedure ReorderPoints (in storeid varchar(10), in Years varchar(10))
begin
SELECT 
    DATE_FORMAT(Date, '%Y-%m') AS Month,
    Store_ID,
    Product_ID,
    ROUND(AVG(Inventory_Level), 1) AS Avg_Inventory_Level,
     IFNULL(ROUND(
        (AVG(Inventory_Level) + 
         LAG(AVG(Inventory_Level)) OVER (
             PARTITION BY Store_ID, Product_ID 
             ORDER BY DATE_FORMAT(Date, '%Y-%m')
         )
        ) / 2, 1
    ),0) AS Avg_Monthly_Inventory,
    2 AS Lead_Time_Days,
    ROUND(1.5 * STDDEV(Units_Sold), 2) AS Safety_Stock,
    ROUND((2 * AVG(Units_Sold)) + (1.5 * STDDEV(Units_Sold)), 2) AS Reorder_Point
FROM inventorydb.inventory
WHERE DATE_FORMAT(Date, '%Y') = '2023'
GROUP BY 
    DATE_FORMAT(Date, '%Y-%m'), 
    Store_ID, 
    Product_ID
ORDER BY Month, Store_ID, Product_ID;
end //
delimiter ;


-- 3. Highlight Supplier Performance Inconsistencies
-- Query: Total units in inventory after ordering (including demand forecast)
SELECT *, (orderedthisMonth + Unit_Left) AS NewInv
FROM (
    SELECT DATE_FORMAT(Date, '%Y-%m') AS YearMonth, Store_ID, Product_ID, 
           SUM(Inventory_Level) AS curr_inv, (SUM(Inventory_Level) - SUM(Units_Sold)) AS Unit_left,
           SUM(Units_Ordered) AS orderedthisMonth, ROUND(SUM(Demand_Forecast), 0) AS demandspermonth
    FROM inventorydb.inventory
    WHERE DATE_FORMAT(Date, '%Y') = '2023'
    GROUP BY DATE_FORMAT(Date, '%Y-%m'), Store_ID, Product_ID
) t;

-- stored procedure
DELIMITER //
CREATE PROCEDURE GetOrderedVsDemand(IN yearInput VARCHAR(4))
BEGIN
    SELECT *, (orderedthisMonth + Unit_Left) AS NewInv
    FROM (
        SELECT DATE_FORMAT(Date, '%Y-%m') AS YearMonth, Store_ID, Product_ID, 
               SUM(Inventory_Level) AS curr_inv, (SUM(Inventory_Level) - SUM(Units_Sold)) AS Unit_left,
               SUM(Units_Ordered) AS orderedthisMonth, ROUND(SUM(Demand_Forecast), 0) AS demandspermonth
        FROM inventorydb.inventory
        WHERE DATE_FORMAT(Date, '%Y') = yearInput
        GROUP BY DATE_FORMAT(Date, '%Y-%m'), Store_ID, Product_ID
    ) t;
END //
DELIMITER ;

-- Query: Percentage of units that do not satisfy the demand forecast
SELECT *, 
       ROW_NUMBER() OVER(PARTITION BY Product_ID, YearMonth ORDER BY Percent_Unsatisfied_Demand DESC) AS MostUnsatisfiedDemands
FROM (
    SELECT DATE_FORMAT(Date, '%Y') AS YearMonth, Store_ID, Product_ID,
           ROUND(100.0 * SUM(CASE WHEN Units_Sold < Demand_Forecast THEN 1 ELSE 0 END) / COUNT(*), 1) AS Percent_Unsatisfied_Demand
    FROM inventorydb.inventory
    GROUP BY YearMonth, Store_ID, Product_ID
    ORDER BY YearMonth, Store_ID
) t;

-- sp
DELIMITER //
CREATE PROCEDURE GetUnsatisfiedDemand(IN yearInput VARCHAR(4))
BEGIN
    SELECT *, 
           ROW_NUMBER() OVER(PARTITION BY Product_ID, YearMonth ORDER BY Percent_Unsatisfied_Demand DESC) AS MostUnsatisfiedDemands
    FROM (
        SELECT DATE_FORMAT(Date, '%Y') AS YearMonth, Store_ID, Product_ID,
               ROUND(100.0 * SUM(CASE WHEN Units_Sold < Demand_Forecast THEN 1 ELSE 0 END) / COUNT(*), 1) AS Percent_Unsatisfied_Demand
        FROM inventorydb.inventory
        WHERE DATE_FORMAT(Date, '%Y') = yearInput
        GROUP BY YearMonth, Store_ID, Product_ID
    ) t;
END //
DELIMITER ;


-- 4. Forecast Demand Trends Based on Seasonal/Cyclical Data
-- Query: Seasonal performance of each product yearly

SELECT * 
FROM (
    SELECT DATE_FORMAT(i.Date, '%Y') AS yy, Seasonality, p.Category,
           ROUND(AVG(((Inventory_Level - Units_Sold) + Units_Ordered) * Price), 1) AS Sales, 
           COUNT(*),
           ROW_NUMBER() OVER(PARTITION BY Seasonality ORDER BY ROUND(AVG(((Inventory_Level - Units_Sold) + Units_Ordered) * Price), 1) DESC) AS ranks
    FROM inventorydb.inventory i
    LEFT JOIN Product p ON p.Product_ID = i.Product_ID
    GROUP BY DATE_FORMAT(i.Date, '%Y'), Seasonality, p.Category
) t
WHERE ranks = 1;

-- sp
DELIMITER //
CREATE PROCEDURE GetSeasonalPerformance(IN yearInput VARCHAR(4))
BEGIN
    SELECT * 
    FROM (
        SELECT DATE_FORMAT(i.Date, '%Y') AS yy, Seasonality, p.Category,
               ROUND(AVG(((Inventory_Level - Units_Sold) + Units_Ordered) * Price), 1) AS Sales, 
               COUNT(*),
               ROW_NUMBER() OVER(PARTITION BY Seasonality ORDER BY ROUND(AVG(((Inventory_Level - Units_Sold) + Units_Ordered) * Price), 1) DESC) AS ranks
        FROM inventorydb.inventory i
        LEFT JOIN Product p ON p.Product_ID = i.Product_ID
        WHERE DATE_FORMAT(i.Date, '%Y') = yearInput
        GROUP BY DATE_FORMAT(i.Date, '%Y'), Seasonality, p.Category
    ) t
    WHERE ranks = 1;
END //
DELIMITER ;

-- Query: Average demand of products based on weather

SELECT DATE_FORMAT(i.Date, '%Y') AS yy, s.Region, i.Weather_Condition,
       ROUND(AVG(i.Demand_Forecast), 2) AS Avg_Demand_Forecast, COUNT(*) AS Record_Count
FROM inventorydb.inventory i
LEFT JOIN Store s ON s.Store_ID = i.Store_ID
GROUP BY DATE_FORMAT(i.Date, '%Y'), i.Weather_Condition, s.Region
ORDER BY Avg_Demand_Forecast DESC;

-- sp
DELIMITER //
CREATE PROCEDURE GetWeatherDemand(IN yearInput VARCHAR(4), IN regionInput VARCHAR(10))
BEGIN
    SELECT DATE_FORMAT(i.Date, '%Y') AS yy, s.Region, i.Weather_Condition,
           ROUND(AVG(i.Demand_Forecast), 2) AS Avg_Demand_Forecast, COUNT(*) AS Record_Count
    FROM inventorydb.inventory i
    LEFT JOIN Store s ON s.Store_ID = i.Store_ID
    WHERE DATE_FORMAT(i.Date, '%Y') = yearInput AND (s.Region = regionInput OR regionInput IS NULL)
    GROUP BY DATE_FORMAT(i.Date, '%Y'), i.Weather_Condition, s.Region
    ORDER BY Avg_Demand_Forecast DESC;
END //
DELIMITER ;

-- Query: Month-over-Month (MoM) Performance (Time Series Analysis)

SELECT YearMonth, Stores, ROUND(current_month_sales, 1) AS current_month_sales,
       ROUND(prev_month_sales, 1) AS prev_month_sales, ROUND(current_month_sales - prev_month_sales, 1) AS MOM_change,
       CASE 
           WHEN prev_month_sales = 0 THEN NULL
           ELSE ROUND(((current_month_sales - prev_month_sales) / prev_month_sales) * 100, 1)
       END AS MOM_percent_change
FROM (
    SELECT DATE_FORMAT(Date, '%Y-%m') AS YearMonth, s.Store_ID AS stores,
           SUM(ROUND(((Inventory_Level - Units_Sold) + Units_Ordered) * Price, 1)) AS current_month_sales,
           LAG(SUM(ROUND(((Inventory_Level - Units_Sold) + Units_Ordered) * Price, 1))) 
               OVER (ORDER BY DATE_FORMAT(Date, '%Y-%m')) AS prev_month_sales
    FROM inventorydb.inventory i
    LEFT JOIN Store s ON s.Store_ID = i.Store_ID
    GROUP BY s.Store_ID, DATE_FORMAT(Date, '%Y-%m')
) AS t
WHERE stores = 'S001';

-- creating stored procedure

delimiter //
create procedure MoMAnalysis (in storenum varchar(10))
begin
SELECT YearMonth, Stores, ROUND(current_month_sales, 1) AS current_month_sales,
       ROUND(prev_month_sales, 1) AS prev_month_sales, ROUND(current_month_sales - prev_month_sales, 1) AS MOM_change,
       CASE 
           WHEN prev_month_sales = 0 THEN NULL
           ELSE ROUND(((current_month_sales - prev_month_sales) / prev_month_sales) * 100, 1)
       END AS MOM_percent_change
FROM (
    SELECT DATE_FORMAT(Date, '%Y-%m') AS YearMonth, s.Store_ID AS stores,
           SUM(ROUND(((Inventory_Level - Units_Sold) + Units_Ordered) * Price, 1)) AS current_month_sales,
           LAG(SUM(ROUND(((Inventory_Level - Units_Sold) + Units_Ordered) * Price, 1))) 
               OVER (ORDER BY DATE_FORMAT(Date, '%Y-%m')) AS prev_month_sales
    FROM inventorydb.inventory i
    LEFT JOIN Store s ON s.Store_ID = i.Store_ID
    GROUP BY s.Store_ID, DATE_FORMAT(Date, '%Y-%m')
) AS t
WHERE stores = storenum;
end //
delimiter ;

-- indexes
-- Composite indexes for inventory table
CREATE INDEX idx_inventory_date_store_product ON inventorydb.inventory (Date, Store_ID, Product_ID);
CREATE INDEX idx_inventory_seasonality ON inventorydb.inventory (Seasonality);
CREATE INDEX idx_inventory_weather ON inventorydb.inventory (Weather_Condition);
CREATE INDEX idx_inventory_demand ON inventorydb.inventory (Demand_Forecast);

-- Indexes for related tables
CREATE INDEX idx_store_storeid ON inventorydb.Store (Store_ID);
CREATE INDEX idx_product_productid_category ON inventorydb.Product (Product_ID, Category);


-- show indexes
-- Check indexes on inventory table
SHOW INDEXES FROM inventorydb.inventory;

-- Check indexes on Product table
SHOW INDEXES FROM inventorydb.Product;

-- Check indexes on Store table
SHOW INDEXES FROM inventorydb.Store;

-- update statistics
ANALYZE TABLE inventorydb.inventory;
ANALYZE TABLE inventorydb.Product;
ANALYZE TABLE inventorydb.Store;



